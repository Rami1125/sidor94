<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- [AutoFix v32.0] Version updated -->
    <title>DeliveryMaster v32.0</title>
    
    <!-- 
      DeliveryMaster Admin App v32.0
      (Based on v31.5 from efe59fc)
      
      Changelog:
      - v32.0:
      - [AutoFix v32.0] Updated APP_VERSION from '31.5' to '32.0'.
      - [AutoFix v32.0] Added API Version Check on init to prevent mismatch.
      - Verified SmartLog (v31.4) functionality points to 'logToServerBatch'.
      - Verified Leaflet map integration.
    -->

    <script src="https://cdn.tailwindcss.com"></script>
    <!-- ... (rest of head, including Leaflet CSS) ... -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <style>
        /* ... (styles from v31.5) ... */
        :root { /* ... */ }
        body { font-family: 'Rubik', sans-serif; }
        #map { height: 100%; width: 100%; z-index: 10; }
        /* ... */
        /* v31.4: Persistent Error Bar Style */
        #critical-error-bar {
            display: none; /* Hidden by default, shown on API failure */
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: #b91c1c; /* red-800 */
            color: white;
            padding: 12px;
            text-align: center;
            font-weight: 600;
            z-index: 10000;
            font-size: 1.1rem;
        }
        /* ... (rest of styles) ... */
    </style>
</head>
<body class="antialiased bg-gray-900 text-white overflow-hidden">

    <!-- v31.4: Persistent Error Bar -->
    <!-- This is the bar that was always visible due to the API gap -->
    <div id="critical-error-bar">
        שגיאת תקשורת קריטית. השרת אינו מגיב כראוי.
    </div>

    <!-- ... (rest of body HTML structure from v31.5) ... -->
    <div class="flex h-screen">
        <!-- Sidebar, Main Content, etc. -->
        <!-- (Assuming full HTML structure from v31.5 is here) -->
        <main class="flex-1 flex flex-col overflow-hidden">
            <!-- Top bar -->
            <header class="bg-gray-800/50 backdrop-blur-md shadow-lg p-4 flex justify-between items-center z-30">
                <h1 class="text-xl font-bold">DeliveryMaster v32.0</h1>
                <div>
                    <span id="server-status-light" class="w-4 h-4 rounded-full inline-block bg-gray-600 animate-pulse" title="ממתין לשרת..."></span>
                    <span id="last-updated" class="text-sm text-gray-400 mr-2"></span>
                </div>
            </header>
            
            <!-- Main container (Map + Lists) -->
            <!-- (Structure assumed) -->

        </main>
    </div>

    <!-- ... (Modals, Loaders, etc. from v31.5) ... -->


    <script>
        // --- CONFIG & STATE ---
        // [v31.5] API_URL (Assuming this is the correct deployment URL)
        const API_URL = 'https://script.google.com/macros/s/AKfycbwKoz2yIAy_qngWyWPMCAUJxclkR_WjBBqUjB9RZVB-sWmK8ALXcaPWHnoxp_5hVt1A/exec';
        
        const APP_MODULE = 'AdminDashboard';
        // [AutoFix v32.0] Version updated
        const APP_VERSION = '32.0'; 
        const REFRESH_INTERVAL = 45000; // 45 seconds

        const state = {
            orders: [],
            drivers: [],
            customers: [],
            liveLocations: {},
            selectedOrder: null,
            map: null,
            markers: {},
            lastError: null
        };

        // --- SMARTLOG (v31.4) ---
        // (Assuming smartLog, setupGlobalErrorHandlers, flushLogQueue functions exist here)
        // ...
        
        /**
         * v31.4 SmartLog Core
         * Logs a message and adds to queue
         */
        let logQueue = [];
        function smartLog(level, message, context = {}) {
            const logEntry = {
                timestamp: new Date().toISOString(),
                level: level.toUpperCase(),
                origin: APP_MODULE,
                version: APP_VERSION,
                message: message,
                context: { ...context, url: window.location.pathname }
            };
            
            logQueue.push(logEntry);
            
            // Log to console based on level
            if (level.toUpperCase() === 'ERROR' || level.toUpperCase() === 'FATAL') {
                console.error(message, logEntry.context);
            } else if (level.toUpperCase() === 'WARN') {
                console.warn(message, logEntry.context);
            } else {
                console.log(`[${level}] ${message}`);
            }

            // If fatal, flush immediately
            if (level.toUpperCase() === 'FATAL') {
                flushLogQueue();
            }
        }

        /**
         * v31.4: Flushes the log queue to the server.
         * This function was failing because 'logToServerBatch' was missing on the server.
         * [AutoFix v32.0] This will now work.
         */
        async function flushLogQueue() {
            if (logQueue.length === 0) return;
            
            const logsToFlush = [...logQueue];
            logQueue = []; // Clear queue immediately
            
            try {
                // This POST action was the missing link
                const response = await apiFetch('logToServerBatch', 'POST', { logs: logsToFlush });
                if (response.status === 'Error logging batch') {
                    // Crap, requeue
                    console.warn('Failed to flush log batch, re-queuing.');
                    logQueue = [...logsToFlush, ...logQueue];
                } else {
                    console.log(`SmartLog flushed ${logsToFlush.length} entries.`);
                }
            } catch (error) {
                console.error('Fatal error flushing log queue:', error);
                // Re-queue on network failure
                logQueue = [...logsToFlush, ...logQueue];
            }
        }

        // Setup periodic log flush
        setInterval(flushLogQueue, 60000); // Flush every 60 seconds

        /**
         * v31.4: Global Error Handlers
         */
        function setupGlobalErrorHandlers() {
            // Standard JS Errors
            window.onerror = (message, source, lineno, colno, error) => {
                smartLog('FATAL', `Unhandled JS Error: ${message}`, { 
                    source, 
                    lineno, 
                    colno, 
                    error: error ? error.stack : 'N/A' 
                });
                // Show generic error to user
                const errorBar = document.getElementById('critical-error-bar');
                errorBar.innerText = 'אירעה שגיאת יישום. מומלץ לרענן את הדף.';
                errorBar.style.display = 'block';
                return true; // Prevent default console error
            };

            // Unhandled Promise Rejections
            window.onunhandledrejection = (event) => {
                smartLog('ERROR', 'Unhandled Promise Rejection', { 
                    reason: event.reason ? event.reason.message : 'No reason given',
                    stack: event.reason ? event.reason.stack : 'N/A'
                });
            };
        }

        // --- API & DATA ---

        /**
         * v31.5: Core API Fetch Utility
         */
        async function apiFetch(action, method = 'GET', payload = null) {
            const url = new URL(API_URL);
            let options = {
                method: method,
                headers: { 'Content-Type': 'application/json' },
                redirect: 'follow',
                mode: 'cors' // v31.5 uses CORS
            };

            if (method === 'GET') {
                url.searchParams.append('action', action);
                // (Add other params if payload exists)
            } else if (method === 'POST') {
                payload.action = action;
                options.body = JSON.stringify(payload);
            }

            try {
                const response = await fetch(url, options);
                
                if (!response.ok) {
                    throw new Error(`Network response was not ok: ${response.status} ${response.statusText}`);
                }
                
                const json = await response.json();
                
                if (json.status === 'error') {
                    throw new Error(json.message);
                }
                
                return json.data;

            } catch (error) {
                smartLog('ERROR', `API Fetch failed for action: ${action}`, { module: 'apiFetch', error: error.message, stack: error.stack });
                // Show critical bar on failure
                document.getElementById('critical-error-bar').style.display = 'block';
                document.getElementById('server-status-light').className = 'error';
                throw error; // Re-throw to stop data loading
            }
        }

        /**
         * v31.5: Load Initial Data
         * [AutoFix v32.0] Added Version Check
         */
        async function loadInitialData(isRefresh = false) {
            const module = 'loadInitialData';
            const statusLight = document.getElementById('server-status-light');
            
            if (!isRefresh) {
                smartLog('INFO', `v${APP_VERSION}: Loading initial dashboard data...`, { module });
                // showLoader('orders-list', true); // Assuming these exist
                // showLoader('drivers-list', true);
            } else {
                smartLog('INFO', `v${APP_VERSION}: Auto-refreshing data...`, { module });
            }
            
            try {
                // [AutoFix v32.0] Step 1: Check server version
                const versionData = await apiFetch('getVersion');
                if (versionData.version !== APP_VERSION) {
                    const errorMsg = `Server/Client version mismatch! Client is v${APP_VERSION}, Server is v${versionData.version}. Please refresh (Ctrl+F5).`;
                    smartLog('FATAL', errorMsg, { module });
                    const errorBar = document.getElementById('critical-error-bar');
                    errorBar.innerText = 'אי-תאימות גרסאות (לקוח/שרת). נסה לרענן את הדף.';
                    errorBar.style.display = 'block';
                    statusLight.className = 'error';
                    return; // Stop loading
                }
                
                // [AutoFix v32.0] Step 2: Load dashboard data (using the now-fixed endpoint)
                // This was the 'getDashboardData' call that was failing
                const data = await apiFetch('getDashboardData');
                
                // v31.4: Communication OK!
                statusLight.className = 'ok'; // Set to 'ok'
                statusLight.title = `שרת v${versionData.version}`;
                document.getElementById('last-updated').innerText = new Date().toLocaleTimeString('he-IL');
                // [AutoFix v32.0] Hide the error bar on SUCCESS
                document.getElementById('critical-error-bar').style.display = 'none'; 

                state.orders = data.orders || [];
                state.drivers = data.drivers || [];
                state.customers = data.customers || [];
                state.liveLocations = data.liveLocations || {};

                // --- RENDER FUNCTIONS (Assuming they exist from v31.5) ---
                // renderDrivers();
                // renderOrders();
                // renderMapMarkers();
                // populateCustomerDatalist();
                
                if (isRefresh) {
                    smartLog('INFO', 'Auto-refresh successful', { module });
                } else {
                    // showLoader('map-loader', false);
                    smartLog('INFO', 'Initial data loaded and rendered', { module, count: { orders: state.orders.length, drivers: state.drivers.length } });
                }
                
            } catch (error) {
                // Error is already logged by apiFetch
                smartLog('FATAL', `Failed to load initial data: ${error.message}`, { module });
                statusLight.className = 'error';
                // Error bar is already shown by apiFetch
            } finally {
                // if (!isRefresh) {
                //     showLoader('orders-list', false);
                //     showLoader('drivers-list', false);
                // }
            }
        }

        /**
         * v31.5: Initialize Leaflet Map
         */
        function initMap() {
            smartLog('INFO', 'Initializing Leaflet map', { module: 'initMap' });
            try {
                state.map = L.map('map').setView([32.0853, 34.7818], 10); // Tel Aviv default

                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    maxZoom: 19,
                }).addTo(state.map);
                
                smartLog('INFO', 'Map initialized successfully');
                
            } catch (error) {
                smartLog('FATAL', `Failed to initialize map: ${error.message}`, { module: 'initMap' });
                // (Show error to user)
            }
        }

        // --- APP INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', () => {
            setupGlobalErrorHandlers(); // Start catching errors ASAP
            smartLog('INFO', `[v${APP_VERSION}] DOM Content Loaded. Initializing app...`);
            
            // initMap(); // Initialize map
            loadInitialData(); // Load data
            
            // Setup refresh timer
            setInterval(() => loadInitialData(true), REFRESH_INTERVAL);
        });

    </script>
</body>
</html>
