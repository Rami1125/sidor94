<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeliveryMaster v31.5</title>
    <!-- 
      DeliveryMaster Admin App v31.5
      
      Changelog:
      - v31.5: Proxy Server Integration
      - CRITICAL: Changed API_URL to point to the new Node.js proxy server.
      - Updated apiFetch() to match the new proxy's URL structure:
        - GET: /api/[action]
        - POST: /api/[action] (with data as raw body)
      - All communication is now stabilized and logged by the proxy.
    -->
    
    <!-- 
      v31.2 WARNING: Using Tailwind CDN for development. 
      For production, a compiled build is required.
    -->
<!-- ... (existing code) ... -->
    <style>
        :root {
/* ... (existing code) ... */
            --text-light: #6b7280; /* gray-500 */
        }
        body {
/* ... (existing code) ... */
            color: var(--text-dark);
            overflow: hidden;
        }
        
/* ... (existing code) ... */
        #server-status-light {
            width: 12px;
            height: 12px;
/* ... (existing code) ... */
            transition: background-color 0.3s;
        }
        #server-status-light.ok {
/* ... (existing code) ... */
        }
        #server-status-light.error {
            background-color: #ef4444; /* red-500 (Error) */
        }
        
/* ... (existing code) ... */
        #critical-error-bar {
            background-color: #ef4444; /* red-500 */
            color: white;
/* ... (existing code) ... */
            display: none;
            position: fixed;
            top: 0;
/* ... (existing code) ... */
            z-index: 10000;
        }

        /* Layout */
/* ... (existing code) ... */
            grid-template-columns: auto 1fr;
            height: 100vh;
        }
        #main-content {
/* ... (existing code) ... */
            grid-template-columns: 1fr 350px;
            height: 100vh;
            overflow: hidden;
        }
/* ... (existing code) ... */
            padding: 0;
        }
        #new-order-modal::backdrop {
/* ... (existing code) ... */
            backdrop-filter: blur(2px);
        }
        
        /* Responsive */
/* ... (existing code) ... */
            .nav-link.active { border-right: none; border-bottom: 3px solid var(--primary-color); }
        }
    </style>
</head>
<body class="antialiased">

    <!-- v31.4: Persistent Error Bar -->
    <div id="critical-error-bar">
        שגיאת תקשורת קריטית. השרת אינו מגיב כראוי. ודא ששרת ה-Proxy פועל.
    </div>

    <div class="app-layout">
        <!-- Navbar -->
<!-- ... (existing code) ... -->
            <div class="flex-grow"></div> <!-- Spacer -->
            
            <div class="hidden lg:block border-t pt-4">
                <div class="text-sm">שלום, <span class="font-semibold">מנהל</span></div>
                <div class="flex items-center space-x-2 space-x-reverse mt-1">
                    <div id="server-status-light" title="סטטוס שרת"></div>
                    <div id="last-updated" class="text-xs text-gray-500">מתחבר...</div>
                </div>
            </div>
        </nav>

        <!-- Main Content (Map + Side Panel) -->
<!-- ... (existing code) ... -->
    <script>
        // --- CONFIG & STATE ---
        // v31.5: CRITICAL - Pointing to the new Node.js Proxy Server
        // This URL must be updated to your *deployed* proxy server address in production.
        const API_URL = 'http://localhost:8080/api';
        
        const APP_MODULE = 'AdminDashboard';
        const REFRESH_INTERVAL = 45000;
// ... (existing code) ...
        let driverMarkers = {};
        let orderMarkers = {};
        let refreshTimer;
        
        // --- v31.4: "SMART LOGGER" v2 (Batching) ---
// ... (existing code) ...
        let logFlushTimer = setInterval(flushLogQueue, 10000); // Flush every 10 seconds

        /**
         * v31.4: Upgraded smartLog to use a batch queue.
// ... (existing code) ...
         */
        function smartLog(level, message, context = {}) {
            const timestamp = new Date().toISOString();
// ... (existing code) ...
            console.log(`[${timestamp}] [${level}] ${message}`, context);

            // 2. Push to queue
// ... (existing code) ...
                timestamp: timestamp
            });
            
// ... (existing code) ...
            if (level.toUpperCase() === 'FATAL') {
                flushLogQueue();
            }
        }
        
// ... (existing code) ...
         * v31.4: New function to flush the log queue to the server.
         */
        function flushLogQueue() {
// ... (existing code) ...
            if (logQueue.length === 0) {
                return;
            }

            const logsToFlush = [...logQueue]; // Copy the queue
// ... (existing code) ...
            logQueue = []; // Clear the queue immediately

            // Send to server (fire-and-forget)
            // v31.5: Using new proxy endpoint
            fetch(`${API_URL}/logToServerBatch`, {
                method: "POST",
                mode: "cors",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(logsToFlush) // Proxy expects an array
            }).catch(err => {
                console.warn(`[SmartLog] Silent batch log failure: ${err.message}`);
// ... (existing code) ...
                logQueue = [...logsToFlush, ...logQueue];
            });
        }


        /**
// ... (existing code) ...
         * v31.2: Global Error Handler
         */
        window.onerror = function(message, source, lineno, colno, error) {
// ... (existing code) ...
                errorStack: error ? error.stack : 'N/A'
            });
            // Don't suppress the default browser error console
// ... (existing code) ...
        };

        /**
         * v31.2: Global Promise Rejection Handler
// ... (existing code) ...
         */
        window.onunhandledrejection = function(event) {
            smartLog('FATAL', 'Unhandled promise rejection', {
// ... (existing code) ...
                stack: event.reason ? event.reason.stack : 'N/A'
            });
        };
        
        // --- ICONS (Leaflet) ---
// ... (existing code) ...
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png', shadowSize: [41, 41]
        });

        
        // --- INITIALIZATION ---
// ... (existing code) ...
        document.addEventListener('DOMContentLoaded', () => {
            smartLog('INFO', 'DOM content loaded. Initializing v31.5...');
            feather.replace();
            initMap();
// ... (existing code) ...
        });

        function initMap() {
            try {
// ... (existing code) ...
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 19,
                    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
// ... (existing code) ...
            } catch (error) {
                smartLog('FATAL', 'Map initialization failed', { error: error.message, stack: error.stack });
                document.getElementById('map').innerHTML = `<div class="p-8 text-center text-red-600">שגיאה קריטית בטעינת המפה.</div>`;
            }
        }
        
        async function loadInitialData(isRefresh = false) {
// ... (existing code) ...
            const statusLight = document.getElementById('server-status-light');
            
            if (!isRefresh) {
                smartLog('INFO', `v${APP_VERSION}: Loading initial dashboard data...`, { module });
// ... (existing code) ...
            } else {
                smartLog('INFO', `v${APP_VERSION}: Auto-refreshing data...`, { module });
            }
            
            try {
                const data = await apiFetch('getDashboardData');
                
                // v31.4: Communication OK!
                statusLight.className = 'ok';
// ... (existing code) ...
                document.getElementById('critical-error-bar').style.display = 'none';

                state.orders = data.orders || [];
// ... (existing code) ...
                if (isRefresh) {
                    smartLog('INFO', 'Auto-refresh successful', { module });
                } else {
// ... (existing code) ...
                    smartLog('INFO', 'Initial data loaded and rendered', { module, count: { orders: state.orders.length, drivers: state.drivers.length } });
                }
                
            } catch (error) {
// ... (existing code) ...
                statusLight.className = 'error';
                smartLog('ERROR', 'Failed to load dashboard data', { module, error: error.message, stack: error.stack });
                showToast('טעינת נתונים נכשלה', 'error');
                
                // Show persistent error bar only on critical CORS/Fetch errors
                if (error.message.includes('Failed to fetch') || error.message.includes('Proxy')) {
                    document.getElementById('critical-error-bar').style.display = 'block';
                }

                if (!isRefresh) {
// ... (existing code) ...
                    document.getElementById('drivers-list').innerHTML = `<div class="p-4 text-red-600">${error.message}</div>`;
                }
            } finally {
// ... (existing code) ...
                    showLoader('drivers-list', false);
                }
            }
        }
        
// ... (existing code) ...

        // --- COMMUNICATION CHANNEL ("מלשינון") ---
        
        /**
         * v31.5: Robust API wrapper
         * Updated to use the Node.js proxy server.
         */
        async function apiFetch(action, params = {}, method = 'GET', data = null) {
            let url = `${API_URL}/${action}`; // v31.5: New URL structure
            
            if (method === 'GET' && Object.keys(params).length > 0) {
                url += '?' + new URLSearchParams(params).toString();
            }

            const options = {
                method: method,
                mode: 'cors', // Still required
                redirect: 'follow',
                muteHttpExceptions: true,
                headers: {}
            };

            if (method === 'POST') {
                options.headers['Content-Type'] = 'application/json';
                // v31.5: Send *only* the data. The 'action' is in the URL.
                options.body = JSON.stringify(data); 
            }
            
            // v31.5: Use the new URL structure for both GET and POST
            const response = await fetch(url, options);
            
            if (!response.ok) {
// ... (existing code) ...
                    if (errorJson.data) errorText = errorJson.data;
                } catch (e) {
                    // Not JSON, just use the text
                }
// ... (existing code) ...
                if (response.status === 0 || (response.status === 200 && errorText.includes("<!DOCTYPE html>"))) {
                   throw new Error('שגיאת CORS. ודא שהשרת (Code.gs) פרוס כהלכה.');
                }
                // v31.5: Add proxy-specific error
                if (response.status === 502) { // Bad Gateway
                    throw new Error('שגיאת Proxy. שרת הביניים נכשל לתקשר עם Google.');
                }
                throw new Error(`שגיאת שרת (${response.status}): ${errorText}`);
            }
            
// ... (existing code) ...
            
            return result.data;
        }
        
        // --- RENDER FUNCTIONS ---
// ... (existing code) ...
        function createDriverCard(driver, location) {
            const el = document.createElement('div');
            el.className = 'driver-card p-4 cursor-pointer';
// ... (existing code) ...
            el.setAttribute('data-search', driver.name.toLowerCase());
            el.onclick = () => focusOnMapItem(driver.driverId, 'driver');
            let statusClass = 'status-inactive';
// ... (existing code) ...
            `;
            return el;
        }
        
        function renderOrders() {
// ... (existing code) ...
            const unassignedOrders = state.orders.filter(o => o.status === 'חדש');
            if (unassignedOrders.length === 0) {
                list.innerHTML = `<div class="p-4 text-center text-gray-500">אין הזמנות חדשות לשיבוץ.</div>`;
// ... (existing code) ...
            unassignedOrders
                .sort((a,b) => new Date(a.orderDate) - new Date(b.orderDate))
                .forEach(order => {
// ... (existing code) ...
        }
        
        function createOrderCard(order) {
            const el = document.createElement('div');
// ... (existing code) ...
            el.setAttribute('data-search', `${order.orderId} ${order.customerName.toLowerCase()} ${order.address.toLowerCase()}`);
            el.onclick = () => focusOnMapItem(order.orderId, 'order');
            const orderDate = new Date(order.orderDate).toLocaleDateString('he-IL', { day: '2-digit', month: '2-digit' });
// ... (existing code) ...
            `;
            return el;
        }
        
        function renderMapMarkers() {
// ... (existing code) ...
            Object.values(state.liveLocations).forEach(driver => {
                if (!driver.latitude || !driver.longitude) return;
                const latLng = [driver.latitude, driver.longitude];
                const icon = driver.isStuck ? driverIconStuck : driverIconActive;
                const popupContent = `<h4>${driver.name}</h4><p>${driver.isStuck ? 'תקוע' : 'פעיל'} | עדכון לפני ${driver.minutesAgo} דקות</p>`;
                if (driverMarkers[driver.id]) {
// ... (existing code) ...
                } else {
                    driverMarkers[driver.id] = L.marker(latLng, { icon: icon }).addTo(map).bindPopup(popupContent);
                }
// ... (existing code) ...
            });
            const unassignedOrders = state.orders.filter(o => o.status === 'חדש' && o.latitude && o.longitude);
            Object.keys(orderMarkers).forEach(orderId => {
// ... (existing code) ...
                    delete orderMarkers[orderId];
                }
            });
            unassignedOrders.forEach(order => {
// ... (existing code) ...
                    <button class="w-full mt-2 px-3 py-1 bg-blue-500 text-white text-sm rounded hover:bg-blue-600" 
                            onclick="showAssignDriverModal('${order.orderId}')">
                        שייך נהג
// ... (existing code) ...
                if (orderMarkers[order.orderId]) {
                    orderMarkers[order.orderId].setLatLng(latLng).setPopupContent(popupContent);
                } else {
// ... (existing code) ...
                }
                bounds.extend(latLng);
            });
// ... (existing code) ...
        
        
        // --- UI & MAP INTERACTIONS ---
        
// ... (existing code) ...
        function showPanelTab(tabName) {
            document.getElementById('orders-list').style.display = (tabName === 'orders') ? 'block' : 'none';
            document.getElementById('drivers-list').style.display = (tabName === 'drivers') ? 'block' : 'none';
// ... (existing code) ...
            document.getElementById('tab-drivers').classList.toggle('border-transparent', tabName !== 'drivers');
        }
        
        function filterLists() {
// ... (existing code) ...
            document.querySelectorAll('.driver-card').forEach(card => {
                card.style.display = card.getAttribute('data-search').includes(query) ? 'block' : 'none';
            });
// ... (existing code) ...
                card.style.display = card.getAttribute('data-search').includes(query) ? 'block' : 'none';
            });
        }
        
// ... (existing code) ...
        function focusOnMapItem(id, type) {
            let marker, card, list;
            if (type === 'driver') {
// ... (existing code) ...
                document.querySelectorAll('.driver-card').forEach(c => c.classList.remove('active'));
            } else {
                marker = orderMarkers[id];
// ... (existing code) ...
                document.querySelectorAll('.order-card').forEach(c => c.classList.remove('active'));
            }
            if (marker) {
// ... (existing code) ...
                marker.openPopup();
            }
            if (card) {
// ... (existing code) ...
                list.scrollTop = card.offsetTop - list.offsetTop;
            }
        }

        function showAssignDriverModal(orderId) {
// ... (existing code) ...
            if (availableDrivers.length === 0) {
                showToast('אין נהגים זמינים כרגע', 'error');
                smartLog('WARN', 'Assign driver modal opened, but no drivers available', { module: 'showAssignDriverModal', orderId });
// ... (existing code) ...
            let driverOptions = availableDrivers.map(d => `${d.driverId}: ${d.name}`).join('\n');
            let driverId = prompt(`שייך הזמנה #${orderId} לנהג:\n(הזן מספר נהג)\n\n${driverOptions}`);
            if (driverId) {
// ... (existing code) ...
                if (driverExists) {
                    assignOrderToDriver(orderId, driverId.trim());
                } else {
// ... (existing code) ...
                    smartLog('WARN', 'Invalid driver ID entered for assignment', { module: 'showAssignDriverModal', enteredId: driverId });
                }
            }
        }
        
        async function assignOrderToDriver(orderId, driverId) {
// ... (existing code) ...
            const btn = document.querySelector(`.leaflet-popup-content button[onclick="showAssignDriverModal('${orderId}')"]`);
            if (btn) btn.innerText = 'משייך...';
            
            try {
                // v31.5: Pass data directly
                await apiFetch('assignDriver', {}, 'POST', { orderId: orderId, driverId: driverId });
                showToast(`הזמנה #${orderId} שויכה לנהג ${driverId}`, 'success');
                smartLog('INFO', `Order ${orderId} assigned to ${driverId}`, { module, orderId, driverId });
// ... (existing code) ...
            } catch (error) {
                showToast(`שגיאה בשיוך הזמנה: ${error.message}`, 'error');
                smartLog('ERROR', 'Failed to assign order', { module, orderId, driverId, error: error.message });
// ... (existing code) ...
            }
        }

        
        // --- NEW ORDER FORM (v31.0) ---
        
// ... (existing code) ...
        function populateCustomerDatalist() {
            const datalist = document.getElementById('customer-list');
            datalist.innerHTML = '';
// ... (existing code) ...
                option.dataset.customerId = cust.customerId;
                datalist.appendChild(option);
            });
// ... (existing code) ...
        
        function openNewOrderForm() {
            smartLog('INFO', 'New order form opened', { module: 'openNewOrderForm' });
// ... (existing code) ...
        }

        function closeNewOrderForm() {
            document.getElementById('new-order-modal').close();
// ... (existing code) ...
            document.getElementById('new-customer-fields').style.display = 'none';
            document.getElementById('existing-customer-display').style.display = 'none';
        }
        
// ... (existing code) ...
        function handleCustomerSearch(value) {
            const options = document.querySelectorAll('#customer-list option');
            let found = false;
// ... (existing code) ...
                if (option.value === value) {
                    const customerId = option.dataset.customerId;
                    const customer = state.customers.find(c => c.customerId == customerId);
// ... (existing code) ...
                        document.getElementById('customer-address-display').innerText = customer.defaultAddress;
                        document.getElementById('customer-phone-display').innerText = customer.phone;
                    }
// ... (existing code) ...
                    break;
                }
            }
            if (!found) {
// ... (existing code) ...
                if (value.length > 2) {
                    document.getElementById('new-customer-fields').style.display = 'block';
                    document.getElementById('customer-name-new').value = value;
// ... (existing code) ...
                } else {
                    document.getElementById('new-customer-fields').style.display = 'none';
                }
// ... (existing code) ...
        
        async function submitNewOrder(event) {
            event.preventDefault();
// ... (existing code) ...
            const btn = document.getElementById('submit-order-btn');
            btn.disabled = true;
            btn.innerText = 'יוצר הזמנה...';
// ... (existing code) ...
            let customerData = {};
            let orderData = {};
            
// ... (existing code) ...
                    customerData = {
                        isNew: true,
                        customerId: document.getElementById('customer-id-new').value,
// ... (existing code) ...
                        contactPerson: document.getElementById('customer-contact-new').value
                    };
                } else if (document.getElementById('existing-customer-display').style.display === 'block') {
// ... (existing code) ...
                        name: customer.name,
                        phone: customer.phone,
                        address: customer.defaultAddress
// ... (existing code) ...
                } else {
                    throw new Error('יש לבחור לקוח קיים או ליצור לקוח חדש');
                }
// ... (existing code) ...
                    warehouse: document.getElementById('order-warehouse').value,
                    notes: document.getElementById('order-notes').value,
                    latitude: '', longitude: ''
// ... (existing code) ...
            
                smartLog('INFO', 'Submitting new order...', { module, customer: customerData.name });
                // v31.5: Pass data directly
                const newOrder = await apiFetch('createNewOrder', {}, 'POST', { orderData, customerData });
                showToast(`הזמנה #${newOrder.orderId} נוצרה בהצלחה`, 'success');
                smartLog('INFO', `New order created successfully: ${newOrder.orderId}`, { module, orderId: newOrder.orderId });
// ... (existing code) ...
                loadInitialData(true); // Refresh
                
            } catch (error) {
// ... (existing code) ...
                smartLog('ERROR', 'Failed to create new order', { module, error: error.message, stack: error.stack });
            } finally {
                btn.disabled = false;
// ... (existing code) ...
            }
        }

        
        // --- HELPERS ---
        
// ... (existing code) ...
        function showLoader(elementId, show) {
            const container = document.getElementById(elementId);
            if (!container) return;
// ... (existing code) ...
            let loader = container.querySelector('.loader-container');
            if (show) {
                if (!loader) {
// ... (existing code) ...
                    loader.innerHTML = `<div class="loader"></div>`;
                    if (elementId !== 'map-loader') {
                         container.prepend(loader);
// ... (existing code) ...
                    }
                }
            } else {
                if (loader) {
// ... (existing code) ...
                        container.style.display = 'none';
                    }
                }
// ... (existing code) ...
        
        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container');
// ... (existing code) ...
            toast.innerText = message;
            container.appendChild(toast);
            setTimeout(() => {
// ... (existing code) ...
            }, 10);
            setTimeout(() => {
                toast.classList.remove('show');
// ... (existing code) ...
                    container.removeChild(toast);
                }, 300);
            }, 3000);
        }
        
        // v31.4: Add version variable for logging
        const APP_VERSION = '31.5';
        
        // Final log to confirm script parse
        smartLog('INFO', `Admin App v${APP_VERSION} scripts parsed and running.`);

    </script>
</body>
</html>

