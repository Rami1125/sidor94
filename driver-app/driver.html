<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>DeliveryMaster </title>

    <!-- PWA Manifest & Theme -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#3a86ff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="https://i.postimg.cc/ryPT3r29/image.png">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Leaflet Map CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500;700&display=swap" rel="stylesheet">

    <!-- Icons -->
    <script src="https://unpkg.com/feather-icons"></script>

    <style>
        body { font-family: 'Rubik', sans-serif; overscroll-behavior-y: contain; }
        #map { height: 250px; border-radius: 0.5rem; }
        .leaflet-control-zoom { display: none; } .leaflet-control-attribution { font-size: 10px; }
        .btn-primary { background-color: #3a86ff; color: white; } .btn-primary:hover { background-color: #2f6ac2; }
        .btn-secondary { background-color: #6c757d; color: white; } .btn-secondary:hover { background-color: #5a6268; }
        .btn-success { background-color: #28a745; color: white; } .btn-success:hover { background-color: #218838; }
        .btn-warning { background-color: #ffc107; color: #212529; } .btn-warning:hover { background-color: #e0a800; }
        .btn-icon { padding: 0.5rem; } .btn-disabled { opacity: 0.6; cursor: not-allowed; }
        .notification-card { border-left: 5px solid #ffc107; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(255, 193, 7, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0); } }
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3a86ff; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">

    <!-- Main Container -->
    <div class="container mx-auto max-w-lg p-0 flex flex-col h-screen">

        <!-- Header -->
        <header class="bg-white shadow-md p-4 flex justify-between items-center sticky top-0 z-10">
            <div>
                <h1 class="text-xl font-bold text-gray-800">DeliveryMaster</h1>
                <p id="driver-name-display" class="text-sm text-gray-600">: 注...</p>
            </div>
            <div id="status-indicator" class="flex items-center space-x-2 space-x-reverse text-sm">
                 <span id="status-text" class="text-yellow-600 font-medium">注...</span> <!-- v50.1: Initial Text -->
                 <div id="status-dot" class="w-3 h-3 bg-yellow-400 rounded-full animate-pulse"></div>
            </div>
        </header>

        <!-- Permission Request Area -->
        <div id="permission-section" class="p-4 space-y-3 bg-yellow-100 border-b border-yellow-300" style="display: none;"> <!-- v50.1: Hidden initially -->
             <p class="text-sm font-medium text-yellow-800">专砖转 专砖转 拽 转专转:</p>
             <button id="request-perms-btn" class="w-full text-sm py-2 px-4 rounded bg-yellow-500 text-white font-semibold hover:bg-yellow-600 transition duration-150">拽砖 专砖转</button>
        </div>

        <!-- Info & Map Area -->
        <div class="p-4">
            <div id="location-info" class="bg-blue-50 p-3 rounded-lg mb-4 text-center text-sm text-blue-800">
                 <p id="current-location-text"> 转专 拽 ...</p>
                 <p id="eta-text" class="mt-1 font-medium hidden">...</p>
            </div>
            <div id="map"></div>
        </div>

        <!-- Order List -->
        <main id="order-list" class="flex-grow overflow-y-auto p-4 space-y-4">
             <div id="loading-orders" class="text-center py-10 text-gray-500">
                 <div class="loader mx-auto mb-2"></div>
                 注 砖转...
             </div>
        </main>

    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Tone.js for Sound -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>


    <!-- Combined & Inlined App Logic -->
    <script type="module">
        console.log('Driver App script started (v50.1)'); // v50.1

        // --- Inlined Firebase SDK Imports ---
        import { initializeApp, getApps, getApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";
        import { getFirestore, collection, doc, onSnapshot, query, orderBy, addDoc, updateDoc, serverTimestamp, deleteDoc, where, writeBatch, setDoc } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js"; // Added setDoc

        // --- Inlined Config Logic ---
        const firebaseConfig = { /* ... config object ... */
            apiKey: "AIzaSyDq0oVwS6zbEfsgrYBRkeBq80dDUKMedzo", authDomain: "saban94-78949.firebaseapp.com", projectId: "saban94-78949",
            storageBucket: "saban94-78949.firebasestorage.app", messagingSenderId: "41553157903", appId: "1:41553157903:web:cc33d252cff023be97a87a", measurementId: "G-XV6RZDESSB"
        };
        let app, auth, db; let initializationError = null;
        try {
            app = getApps().length ? getApp() : initializeApp(firebaseConfig); console.log("Firebase app instance ensured.");
            auth = getAuth(app); db = getFirestore(app);
        } catch (error) { console.error("CRITICAL: Firebase init failed!", error); initializationError = error; }

        const MAX_AUTH_RETRIES = 3; const RETRY_DELAY_MS = 3000;
        async function ensureAuth() { /* ... Same ensureAuth logic ... */
            console.log("ensureAuth: Starting..."); let tries = 0;
            while (tries < MAX_AUTH_RETRIES) {
                tries++;
                try {
                    if (initializationError) throw new Error(`Init failed: ${initializationError.message}`);
                    if (!auth) throw new Error("Auth object missing");
                    console.log(`ensureAuth: Attempt ${tries}/${MAX_AUTH_RETRIES}...`);
                    const userCredential = await signInAnonymously(auth);
                    console.log("ensureAuth: Success.", userCredential.user.uid); return userCredential.user;
                } catch (e) {
                    console.warn(`[FirebaseAuth] Attempt ${tries} failed:`, e.code, e.message);
                    if (tries >= MAX_AUTH_RETRIES) { console.error("ensureAuth: All attempts failed."); throw e; }
                    console.log(`ensureAuth: Retrying in ${RETRY_DELAY_MS / 1000}s...`); await new Promise(r => setTimeout(r, RETRY_DELAY_MS));
                }
            } throw new Error("ensureAuth: Max retries reached.");
        }
        const authReadyPromise = ensureAuth();
        console.log("Config part executed.");

        // --- Inlined SmartLog Logic (v50.1: Simplified await logic) ---
        const LOG_COLLECTION = 'system_logs_v3'; const sessionId = (Date.now() + Math.random()).toString(36);
        let isDbAvailable = !!db; let isAuthReadyForLogging = false; // v50.1: Separate flag for logging
        authReadyPromise.then(() => { isAuthReadyForLogging = true; console.log("SmartLog: Auth is ready for logging."); })
                      .catch(() => { console.warn("SmartLog: Auth failed, Firestore logging disabled."); isDbAvailable = false; }); // Disable DB logging if auth fails

        const writeLog = async (level, message, origin, context = {}, category = null, solution = null) => {
             const consoleArgs = [`[${origin}] ${level}:`, message]; if (Object.keys(context).length > 0) consoleArgs.push(context); /* ... */
            switch (level) { case 'INFO': console.log(...consoleArgs); break; case 'WARN': console.warn(...consoleArgs); break; case 'ERROR': console.error(...consoleArgs); break; default: console.log(...consoleArgs); }
            if (!isDbAvailable || !isAuthReadyForLogging) { return; } // v50.1: Check flag
            try {
                // No need to await here anymore, flag ensures auth is ready or DB logging is disabled
                const user = auth?.currentUser; if (!user) { return; }
                const userContext = { uid: user.uid, isAnonymous: user.isAnonymous };
                const logEntry = {
                    timestamp: serverTimestamp(), level, message: String(message), origin,
                    context: { ...JSON.parse(JSON.stringify(context || {})), sessionId, userAgent: navigator.userAgent || 'N/A', page: window.location.pathname || '/driver-app/' },
                    user: userContext, category: category || null, solution: solution || null
                };
                await addDoc(collection(db, LOG_COLLECTION), logEntry);
            } catch (error) { console.error("SmartLog FATAL ERROR writing to Firestore.", error); if (error.code === 'permission-denied') { console.warn("SmartLog: Disabling Firestore logging."); isDbAvailable = false; } }
         };
        const SmartLog = {
            info: (msg, origin, ctx = {}) => { writeLog('INFO', msg, origin, ctx); },
            warn: (msg, origin, ctx = {}, cat = null, sol = null) => { writeLog('WARN', msg, origin, ctx, cat, sol); },
            error: (err, origin, ctx = {}, cat = null, sol = null) => { const msg = err instanceof Error ? err.message : String(err); const stack = err instanceof Error ? err.stack : 'N/A'; writeLog('ERROR', msg, origin, { ...ctx, stack }, cat, sol); }
        };
        console.log("SmartLog part executed.");


        // --- Driver App Specific Logic ---

        // Globals
        let map; let driverMarker;
        let currentDriverId = localStorage.getItem('driverId');
        let currentDriverName = localStorage.getItem('driverName');
        let watchId = null; let currentOrders = {}; let notificationAudio = null;
        let hasNotificationPermission = false; let hasGeolocationPermission = false;
        let lastLocationUpdate = 0;

        // DOM Elements (v50.1: Defined after DOMContentLoaded)
        let DOM = {};

        // --- Initialization ---
        async function initializeDriverApp() {
            // v50.1: Define DOM elements here, after DOMContentLoaded
            DOM = {
                 driverNameDisplay: document.getElementById('driver-name-display'), statusText: document.getElementById('status-text'), statusDot: document.getElementById('status-dot'),
                 permissionSection: document.getElementById('permission-section'), requestPermsBtn: document.getElementById('request-perms-btn'), locationInfo: document.getElementById('location-info'),
                 currentLocationText: document.getElementById('current-location-text'), etaText: document.getElementById('eta-text'), mapElement: document.getElementById('map'), orderList: document.getElementById('order-list'), loadingOrders: document.getElementById('loading-orders')
            };
            SmartLog.info("DOM elements referenced.", "Init.DOM");
            if (!DOM.driverNameDisplay || !DOM.statusText || !DOM.mapElement || !DOM.orderList) {
                 throw new Error("Essential DOM elements missing!"); // Let the main catch block handle this
            }

            SmartLog.info("Initializing Driver App (v50.1)...", "Init");
            try {
                // Check for saved driver ID
                if (!currentDriverId || !currentDriverName) {
                    SmartLog.error(new Error("Missing driverId/Name"), "Auth", null, "Auth", "  专. 驻 祝 转专转.");
                    window.location.href = 'login.html'; return;
                }
                DOM.driverNameDisplay.textContent = `: ${currentDriverName}`;

                // Wait for Firebase Auth
                updateStatus("转 转...", "yellow", true);
                await authReadyPromise;
                SmartLog.info("Firebase Auth Ready.", "Init");

                // Check and Request Permissions
                await checkAndRequestPermissions(); // This function now handles displaying the section

                // Initialize Map
                updateStatus("转 驻...", "yellow", true);
                initMap();

                // Start Geolocation only if permission granted
                if (hasGeolocationPermission) {
                    updateStatus("驻注 GPS...", "yellow", true);
                    startGeolocation();
                } else {
                     updateStatus("转 砖专 拽", "red", false);
                     SmartLog.warn("Geolocation permission pending/denied. GPS not started.", "Permissions");
                }

                // Initialize Notifications
                 initNotifications();

                // Attach Order Listener
                updateStatus("住专 砖转...", "yellow", true);
                listenToOrders();

                // Final status depends on permissions & GPS state
                updateFinalStatus(); // v50.1: Helper function for clarity

                SmartLog.info("Driver App Initialization Complete.", "Init");

            } catch (error) {
                SmartLog.error(error, "Init.Critical");
                updateStatus(`砖转 转: ${error.message}`, "red", false);
            }
        }

         // v50.1: Helper to set final status text
         function updateFinalStatus() {
             if (watchId) {
                 updateStatus("GPS 驻注", "green", false);
             } else if (!hasGeolocationPermission) {
                 updateStatus("转 砖专 拽", "red", false);
             } else {
                 updateStatus("GPS  驻注", "yellow", false); // e.g., if error occurred
             }
         }

        // --- Status Update ---
        function updateStatus(text, color = "gray", pulse = false) {
             // Safety check for DOM elements added
             if (!DOM.statusText || !DOM.statusDot) { console.warn("Status elements not ready for update:", text); return; }
             SmartLog.info(`Updating Status: ${text}`, "UI.Status", { color, pulse });
             DOM.statusText.textContent = text;
             DOM.statusText.className = `text-sm font-medium text-${color}-600`; // Simpler class update
             DOM.statusDot.className = `w-3 h-3 rounded-full bg-${color}-400 ${pulse ? 'animate-pulse' : ''}`;
        }

        // --- Permissions ---
        async function checkAndRequestPermissions() {
             SmartLog.info("Checking permissions...", "Permissions");
             let needsGeoRequest = false;
             let needsNotifRequest = false;

             // Geolocation
             try {
                const geoStatus = await navigator.permissions.query({ name: 'geolocation' });
                hasGeolocationPermission = geoStatus.state === 'granted';
                if (geoStatus.state === 'prompt') needsGeoRequest = true;
                SmartLog.info("Geolocation status:", "Permissions", { status: geoStatus.state });
             } catch (e) { SmartLog.warn("Could not query geo permission.", "Permissions", e); needsGeoRequest = true; }

             // Notifications
             if ('Notification' in window) {
                hasNotificationPermission = Notification.permission === 'granted';
                if (Notification.permission === 'default') needsNotifRequest = true;
                SmartLog.info("Notification status:", "Permissions", { status: Notification.permission });
             } else { SmartLog.warn("Notifications not supported.", "Permissions"); }

             if (needsGeoRequest || needsNotifRequest) {
                 if (DOM.permissionSection && DOM.requestPermsBtn) {
                     DOM.permissionSection.style.display = 'block';
                     // Ensure only one listener is attached
                     DOM.requestPermsBtn.removeEventListener('click', handlePermissionRequest); // Remove previous if any
                     DOM.requestPermsBtn.addEventListener('click', handlePermissionRequest);
                     updateStatus("转 砖专 专砖转", "yellow", true);
                 } else { SmartLog.error("Permission UI elements not found!", "Permissions"); }
             } else {
                 if (DOM.permissionSection) DOM.permissionSection.style.display = 'none';
                 SmartLog.info("Permissions already handled.", "Permissions");
             }
        }

        async function handlePermissionRequest() { /* ... implementation unchanged ... */
             SmartLog.info("Requesting permissions via button click...", "Permissions");
            let geoGranted = hasGeolocationPermission;
            let notifGranted = hasNotificationPermission;

            // Request Geolocation
            if (!hasGeolocationPermission) {
                try {
                    // Try getting position first, it often triggers the prompt better
                    await new Promise((resolve, reject) => { navigator.geolocation.getCurrentPosition(resolve, reject, { timeout: 15000 }); });
                    const geoStatus = await navigator.permissions.query({ name: 'geolocation' });
                    geoGranted = geoStatus.state === 'granted';
                    hasGeolocationPermission = geoGranted;
                    SmartLog.info("Geolocation request result:", "Permissions", { status: geoStatus.state });
                    if(geoGranted && !watchId) startGeolocation();
                 } catch (e) { SmartLog.error(e, "Permissions", { message: "Geolocation request failed." }); }
            }

            // Request Notifications
            if ('Notification' in window && Notification.permission === 'default') {
                try {
                    const permission = await Notification.requestPermission();
                    notifGranted = permission === 'granted';
                    hasNotificationPermission = notifGranted;
                    SmartLog.info("Notification request result:", "Permissions", { status: permission });
                     if(notifGranted) initNotifications();
                } catch (e) { SmartLog.error(e, "Permissions", { message: "Notification request failed." }); }
            }

            if (geoGranted) { // Only hide if Geo is granted, as it's essential
                if (DOM.permissionSection) DOM.permissionSection.style.display = 'none';
                updateFinalStatus(); // Update status based on current state
            } else {
                 updateStatus("专砖转 专砖转 拽!", "red", false);
                 if (DOM.requestPermsBtn) {
                    DOM.requestPermsBtn.textContent = "拽砖 专砖转 拽 砖";
                    DOM.requestPermsBtn.classList.add('btn-disabled');
                    setTimeout(() => DOM.requestPermsBtn.classList.remove('btn-disabled'), 5000);
                 }
            }
        }

        // --- Geolocation & Location Update ---
        function startGeolocation() { /* ... implementation unchanged ... */
            if (watchId) { SmartLog.info("Geolocation already watching.", "GPS"); return; }
            if (!hasGeolocationPermission) { SmartLog.warn("Cannot start GPS, permission not granted.", "GPS"); updateStatus("专砖转 专砖转 拽", "red", false); return; }
            if (!('geolocation' in navigator)) { SmartLog.error("Geolocation not supported.", "GPS"); return; }

            SmartLog.info("Starting geolocation watchPosition...", "GPS");
            updateStatus("驻注 GPS...", "yellow", true);

            watchId = navigator.geolocation.watchPosition(
                async (position) => {
                    const { latitude, longitude, accuracy } = position.coords;
                    SmartLog.info("GPS Update Received", "GPS", { lat: latitude, lon: longitude, acc: accuracy });
                    updateStatus("GPS 驻注", "green", false);
                    updateDriverMarkerOnMap(latitude, longitude);
                    updateLocationText(latitude, longitude);
                    const now = Date.now();
                    if (now - lastLocationUpdate > 20000) { // Throttle Firestore updates
                        SmartLog.info("Sending location update to Firestore...", "GPS.Firestore");
                        await updateLocationInFirestore(latitude, longitude);
                        lastLocationUpdate = now;
                    }
                },
                (error) => {
                    SmartLog.error(error, "GPS.Error");
                    let errorMsg = "砖转 GPS"; if (error.code === 1) errorMsg = "GPS:  专砖"; else if (error.code === 2) errorMsg = "GPS:  "; else if (error.code === 3) errorMsg = "GPS: Timeout";
                    updateStatus(errorMsg, "red", false);
                    if(watchId) { navigator.geolocation.clearWatch(watchId); watchId = null; }
                },
                { enableHighAccuracy: true, timeout: 15000, maximumAge: 5000 }
            );
        }
        async function updateLocationInFirestore(lat, lng) { /* ... implementation unchanged ... */
             if (!db || !currentDriverId) return; const locationRef = doc(db, "driverLocations", currentDriverId);
             try { await updateDoc(locationRef, { latitude: lat, longitude: lng, lastUpdate: serverTimestamp() }); SmartLog.info("Location updated in Firestore.", "GPS.Firestore");
             } catch (e) { if (e.code === 'not-found') { SmartLog.warn("Location doc not found, creating...", "GPS.Firestore"); try { await setDoc(locationRef, { latitude: lat, longitude: lng, lastUpdate: serverTimestamp(), driverName: currentDriverName }); SmartLog.info("Location doc created.", "GPS.Firestore"); } catch (createError) { SmartLog.error(createError, "GPS.Firestore.Create"); } } else { SmartLog.error(e, "GPS.Firestore.Update"); } }
        }
        async function updateLocationText(lat, lng) { /* ... implementation unchanged ... */
            if (!DOM.currentLocationText) return; DOM.currentLocationText.textContent = ` ${lat.toFixed(4)}, ${lng.toFixed(4)}`;
            try { const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=16`); if (!response.ok) throw new Error(`${response.status}`); const data = await response.json(); if (data?.display_name) { const parts = data.display_name.split(', '); const short = parts.slice(0, 3).join(', '); DOM.currentLocationText.textContent = ` ${short}`; SmartLog.info("Reverse geocode success", "GPS.Geo", { address: short }); } else { SmartLog.warn("Reverse geocode failed: No display_name", "GPS.Geo", { data }); } } catch (error) { SmartLog.error(error, "GPS.ReverseGeocode"); }
        }

        // --- Map Handling ---
        function initMap() { /* ... implementation unchanged ... */
             try { map = L.map(DOM.mapElement).setView([32.0853, 34.7818], 13); L.tileLayer('https{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OSM', maxZoom: 18, }).addTo(map); SmartLog.info("Map initialized", "Map"); } catch (e) { SmartLog.error(e, "Map.Init"); if (DOM.mapElement) DOM.mapElement.innerHTML = '<p class="text-red-500 p-4 text-center">Map Error</p>'; }
        }
        function updateDriverMarkerOnMap(lat, lng) { /* ... implementation unchanged ... */
             if (!map) return; const latLng = [lat, lng]; if (driverMarker) { driverMarker.setLatLng(latLng); } else { driverMarker = L.circleMarker(latLng, { radius: 8, fillColor: "#3a86ff", color: "#fff", weight: 2, opacity: 1, fillOpacity: 0.8 }).addTo(map); SmartLog.info("Driver marker added", "Map"); } map.panTo(latLng);
        }

        // --- Order Handling ---
        function listenToOrders() { /* ... implementation unchanged ... */
             SmartLog.info("Listening to orders:", "Orders", { driverId: currentDriverId }); const q = query( collection(db, "orders"), where("driver.id", "==", currentDriverId), where("status", "in", ["砖", "转 拽", "专"]) );
             onSnapshot(q, (snapshot) => { SmartLog.info(`Orders snapshot: ${snapshot.docChanges().length} changes`, "Orders"); if (DOM.loadingOrders) DOM.loadingOrders.style.display = 'none'; let newOrderDetected = false;
                 snapshot.docChanges().forEach((change) => { const orderId = change.doc.id; const orderData = { id: orderId, ...change.doc.data() };
                     if (change.type === "added") { SmartLog.info("New order:", "Orders", { orderId }); currentOrders[orderId] = orderData; if (orderData.status === '砖') newOrderDetected = true; }
                     else if (change.type === "modified") { SmartLog.info("Order modified:", "Orders", { orderId, status: orderData.status }); currentOrders[orderId] = orderData; }
                     else if (change.type === "removed") { SmartLog.info("Order removed:", "Orders", { orderId }); delete currentOrders[orderId]; } });
                 renderOrderList(); if (newOrderDetected) handleNewOrderNotification();
             }, (error) => { SmartLog.error(error, "Orders.Listener"); updateStatus("Sync Error", "red", false); if (DOM.loadingOrders) DOM.loadingOrders.innerHTML = '<p class="text-red-500">Sync Error</p>'; });
        }
        function renderOrderList() { /* ... implementation unchanged ... */
             const ordersArray = Object.values(currentOrders).sort((a, b) => (a.status === '砖' ? -1 : 1)); if (!DOM.orderList) return;
             if (ordersArray.length === 0) { DOM.orderList.innerHTML = `<p class="text-center text-gray-500 py-10"> 砖转 驻注转.</p>`; return; }
             DOM.orderList.innerHTML = ordersArray.map(order => createOrderCard(order)).join(''); try{feather.replace();} catch(e){}
        }
        function createOrderCard(order) { /* ... implementation unchanged ... */
            let cardClass = "bg-white p-4 rounded-lg shadow"; let actionButton = ''; let statusText = order.status || '?'; let statusColor = "text-gray-500";
            switch (order.status) {
                case '砖': cardClass += " notification-card"; statusText = "砖 - 砖专"; statusColor = "text-yellow-600 font-bold"; actionButton = `<button class="w-full py-2 px-4 rounded bg-green-500 text-white font-semibold hover:bg-green-600 transition btn-success" onclick="window.acknowledgeOrder('${order.id}')"><i data-feather="check-circle" class="inline w-4 h-4 ml-1"></i> 砖专 转转 注住</button>`; break;
                case '转 拽': statusText = "注住"; statusColor = "text-blue-600"; actionButton = `<p class="text-center text-sm text-gray-500 italic">转 住 注住...</p>`; break;
                case '专': statusText = "专 拽"; statusColor = "text-green-600 font-semibold"; actionButton = `<button class="w-full py-2 px-4 rounded bg-green-600 text-white font-semibold hover:bg-green-700 transition btn-success" onclick="window.completeOrder('${order.id}')"><i data-feather="flag" class="inline w-4 h-4 ml-1"></i> 住 砖</button>`; break;
                default: cardClass += " opacity-70";
            }
            const buttons = `<div class="grid grid-cols-2 gap-2 mt-3 text-sm"><a href="tel:${order.customer?.phone || ''}" class="py-2 px-3 rounded bg-gray-200 text-gray-700 font-medium hover:bg-gray-300 transition text-center"><i data-feather="phone" class="inline w-4 h-4 ml-1"></i> 拽</a><a href="https://www.google.com/maps/dir/?api=1&destination=${encodeURIComponent(order.address || '')}" target="_blank" class="py-2 px-3 rounded bg-blue-500 text-white font-medium hover:bg-blue-600 transition text-center"><i data-feather="navigation" class="inline w-4 h-4 ml-1"></i> </a></div>`;
            return `<div class="${cardClass}" id="order-${order.id}"><div class="flex justify-between items-start mb-2"><div><h3 class="text-lg font-bold text-gray-900">${order.customer?.name || '?'}</h3><p class="text-sm text-gray-600">${order.address || '?'}</p></div><span class="text-xs font-medium ${statusColor} whitespace-nowrap">${statusText}</span></div><p class="text-xs text-gray-500 mb-3">注专转: ${order.notes || ''}</p>${actionButton}${buttons}</div>`;
        }

        // --- Order Actions ---
        window.acknowledgeOrder = async (orderId) => { /* ... implementation unchanged ... */
            SmartLog.info("Acknowledging order...", "Orders.Action", { orderId }); try { const orderRef = doc(db, "orders", orderId); await updateDoc(orderRef, { status: "转 拽" }); SmartLog.info("Status updated to '转 拽'", "Orders.Action", { orderId }); stopNotificationSound(); document.getElementById(`order-${orderId}`)?.classList.remove('notification-card'); } catch (e) { SmartLog.error(e, "Orders.Action.Acknowledge"); alert("砖 砖专."); }
        };
        window.completeOrder = async (orderId) => { /* ... implementation unchanged ... */
             SmartLog.info("Completing order...", "Orders.Action", { orderId }); if (!confirm("住 砖 砖?")) return; try { const orderRef = doc(db, "orders", orderId); await updateDoc(orderRef, { status: "砖", completedAt: serverTimestamp() }); SmartLog.info("Status updated to '砖'", "Orders.Action", { orderId }); } catch (e) { SmartLog.error(e, "Orders.Action.Complete"); alert("砖 住."); }
        };

        // --- Notifications ---
        function initNotifications() { /* ... implementation unchanged ... */
             if (!hasNotificationPermission || !window.Tone) return; try { notificationAudio = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 } }).toDestination(); SmartLog.info("Audio initialized.", "Notifications"); } catch (e) { SmartLog.error(e, "Notifications.InitAudio"); }
        }
        function handleNewOrderNotification() { /* ... implementation unchanged ... */
             SmartLog.info("New order notification...", "Notifications");
             if (notificationAudio && Tone?.context?.state === 'running') { try { notificationAudio.triggerAttackRelease("C5", "8n", Tone.now()); notificationAudio.triggerAttackRelease("G5", "8n", Tone.now() + 0.2); SmartLog.info("Sound played.", "Notifications"); } catch(e) { SmartLog.error(e, "Notifications.PlaySound"); } }
             else if (notificationAudio) { Tone.start().then(() => { SmartLog.info("Audio context resumed. Retrying sound.", "Notifications"); try { notificationAudio.triggerAttackRelease("C5", "8n", Tone.now()); notificationAudio.triggerAttackRelease("G5", "8n", Tone.now() + 0.2); } catch(e) { SmartLog.error(e, "Notifications.PlaySoundRetry"); } }).catch(e => SmartLog.error(e, "Notifications.ToneStartFailed")); }
             else { SmartLog.warn("Cannot play sound.", "Notifications"); }
             if (hasNotificationPermission && 'Notification' in window) { const notification = new Notification(" 砖!", { body: "砖 砖 转 砖专.", icon: "https://i.postimg.cc/ryPT3r29/image.png", vibrate: [200, 100, 200] }); notification.onclick = () => { window.focus(); SmartLog.info("Notification clicked.", "Notifications"); }; SmartLog.info("Browser notification shown.", "Notifications"); }
             else { SmartLog.warn("Cannot show browser notification.", "Notifications"); }
        }
        function stopNotificationSound() { /* ... implementation unchanged ... */
             SmartLog.info("Stopping sound (placeholder).", "Notifications");
        }

        // --- Service Worker Registration ---
        function registerServiceWorker() { /* ... implementation unchanged ... */
            if ('serviceWorker' in navigator) { window.addEventListener('load', () => { navigator.serviceWorker.register('./sw.js').then(reg => SmartLog.info('SW registered', 'PWA', { scope: reg.scope })).catch(err => SmartLog.error(err, 'PWA', { message: 'SW registration failed' })); }); } else { SmartLog.warn("SW not supported.", "PWA"); }
        }


        // --- Start Application (v50.1: Moved into DOMContentLoaded) ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOMContentLoaded fired (v50.1). Starting app initialization...'); // v50.1
            // Ensure SmartLog is available (basic check)
            if (typeof SmartLog === 'undefined') {
                // Attempt to define fallback if SmartLog failed (might happen if imports fail very early)
                console.error("SmartLog failed to initialize. Using console fallback.");
                 SmartLog = { info: console.log, warn: console.warn, error: console.error };
            }
            SmartLog.info("DOMContentLoaded fired.", "Init");
            registerServiceWorker();
            initializeDriverApp(); // Start main async logic
             try { if(feather) feather.replace(); } catch (e) { SmartLog.warn("Feather icons replace failed.", "UI", e); }
        });

    </script>

</body>
</html>
