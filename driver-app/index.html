<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>DeliveryMaster </title>

    <!-- PWA Manifest & Theme -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#3a86ff"> <!-- Match manifest -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="https://i.postimg.cc/ryPT3r29/image.png"> <!-- Use your icon -->


    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Leaflet Map CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <!-- Google Fonts (Optional, adjust as needed) -->
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500;700&display=swap" rel="stylesheet">

    <!-- Icons -->
    <script src="https://unpkg.com/feather-icons"></script>


    <style>
        body {
            font-family: 'Rubik', sans-serif;
            overscroll-behavior-y: contain; /* Prevent pull-to-refresh */
        }
        /* Style for map */
        #map { height: 250px; border-radius: 0.5rem; }
        .leaflet-control-zoom { display: none; } /* Hide zoom controls initially */
         .leaflet-control-attribution { font-size: 10px; }

        /* Custom Button Styles */
        .btn-primary { background-color: #3a86ff; color: white; }
        .btn-primary:hover { background-color: #2f6ac2; }
        .btn-secondary { background-color: #6c757d; color: white; }
        .btn-secondary:hover { background-color: #5a6268; }
        .btn-success { background-color: #28a745; color: white; }
        .btn-success:hover { background-color: #218838; }
        .btn-warning { background-color: #ffc107; color: #212529; }
        .btn-warning:hover { background-color: #e0a800; }
        .btn-icon { padding: 0.5rem; } /* Smaller padding for icon buttons */
        .btn-disabled { opacity: 0.6; cursor: not-allowed; }

        /* Notification Styling */
        .notification-card {
            border-left: 5px solid #ffc107; /* Yellow border for new */
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 193, 7, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0); }
        }
        /* Loader */
         .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3a86ff; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; }
         @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    </style>
</head>
<body class="bg-gray-100 min-h-screen">

    <!-- Main Container -->
    <div class="container mx-auto max-w-lg p-0 flex flex-col h-screen">

        <!-- Header -->
        <header class="bg-white shadow-md p-4 flex justify-between items-center sticky top-0 z-10">
            <div>
                <h1 class="text-xl font-bold text-gray-800">DeliveryMaster</h1>
                <p id="driver-name-display" class="text-sm text-gray-600">: 注...</p>
            </div>
            <div id="status-indicator" class="flex items-center space-x-2 space-x-reverse text-sm">
                 <span id="status-text" class="text-yellow-600 font-medium">转...</span>
                 <div id="status-dot" class="w-3 h-3 bg-yellow-400 rounded-full animate-pulse"></div>
            </div>
        </header>

        <!-- Permission Request Area -->
        <div id="permission-section" class="p-4 space-y-3 bg-yellow-100 border-b border-yellow-300">
             <p class="text-sm font-medium text-yellow-800">专砖转 专砖转 拽 转专转:</p>
             <button id="request-perms-btn" class="w-full text-sm py-2 px-4 rounded bg-yellow-500 text-white font-semibold hover:bg-yellow-600 transition duration-150">拽砖 专砖转</button>
        </div>

        <!-- Info & Map Area -->
        <div class="p-4">
            <!-- Current Location & ETA -->
            <div id="location-info" class="bg-blue-50 p-3 rounded-lg mb-4 text-center text-sm text-blue-800">
                 <p id="current-location-text"> 转专 拽 ...</p>
                 <p id="eta-text" class="mt-1 font-medium hidden">...</p>
            </div>

            <!-- Map -->
            <div id="map"></div>
        </div>

        <!-- Order List -->
        <main id="order-list" class="flex-grow overflow-y-auto p-4 space-y-4">
            <!-- Order cards will be injected here -->
             <div id="loading-orders" class="text-center py-10 text-gray-500">
                 <div class="loader mx-auto mb-2"></div>
                 注 砖转...
             </div>
        </main>

    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Tone.js for Sound -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>


    <!-- Combined & Inlined App Logic -->
    <script type="module">
        console.log('Driver App script started (v50.0)');

        // --- Inlined Firebase SDK Imports ---
        import { initializeApp, getApps, getApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";
        import { getFirestore, collection, doc, onSnapshot, query, orderBy, addDoc, updateDoc, serverTimestamp, deleteDoc, where, writeBatch } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";
        // import { getFunctions } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-functions.js"; // Not used currently

        // --- Inlined Config Logic ---
        const firebaseConfig = {
          apiKey: "AIzaSyDq0oVwS6zbEfsgrYBRkeBq80dDUKMedzo", authDomain: "saban94-78949.firebaseapp.com", projectId: "saban94-78949",
          storageBucket: "saban94-78949.firebasestorage.app", messagingSenderId: "41553157903", appId: "1:41553157903:web:cc33d252cff023be97a87a", measurementId: "G-XV6RZDESSB"
        };
        let app, auth, db; let initializationError = null;
        try {
            app = getApps().length ? getApp() : initializeApp(firebaseConfig); console.log("Firebase app instance ensured.");
            auth = getAuth(app); db = getFirestore(app);
        } catch (error) { console.error("CRITICAL: Firebase init failed!", error); initializationError = error; }

        const MAX_AUTH_RETRIES = 3; const RETRY_DELAY_MS = 3000;
        async function ensureAuth() { /* ... Same ensureAuth logic as admin-hub v49.3 ... */
            console.log("ensureAuth: Starting..."); let tries = 0;
            while (tries < MAX_AUTH_RETRIES) {
                tries++;
                try {
                    if (initializationError) throw new Error(`Init failed: ${initializationError.message}`);
                    if (!auth) throw new Error("Auth object missing");
                    console.log(`ensureAuth: Attempt ${tries}/${MAX_AUTH_RETRIES}...`);
                    const userCredential = await signInAnonymously(auth);
                    console.log("ensureAuth: Success.", userCredential.user.uid); return userCredential.user;
                } catch (e) {
                    console.warn(`[FirebaseAuth] Attempt ${tries} failed:`, e.code, e.message);
                    if (tries >= MAX_AUTH_RETRIES) { console.error("ensureAuth: All attempts failed."); throw e; }
                    console.log(`ensureAuth: Retrying in ${RETRY_DELAY_MS / 1000}s...`); await new Promise(r => setTimeout(r, RETRY_DELAY_MS));
                }
            } throw new Error("ensureAuth: Max retries reached.");
        }
        const authReadyPromise = ensureAuth();
        console.log("Config part executed.");

        // --- Inlined SmartLog Logic ---
        const LOG_COLLECTION = 'system_logs_v3'; const sessionId = (Date.now() + Math.random()).toString(36);
        let isDbAvailable = !!db; let authChecked = false;
        const writeLog = async (level, message, origin, context = {}, category = null, solution = null) => { /* ... Same writeLog logic as admin-hub v49.3 ... */
             const consoleArgs = [`[${origin}] ${level}:`, message]; if (Object.keys(context).length > 0) consoleArgs.push(context); if (category) consoleArgs.push(`[Cat: ${category}]`); if (solution) consoleArgs.push(`[Sol: ${solution}]`);
            switch (level) { case 'INFO': console.log(...consoleArgs); break; case 'WARN': console.warn(...consoleArgs); break; case 'ERROR': console.error(...consoleArgs); break; default: console.log(...consoleArgs); }
            if (!isDbAvailable) { return; }
            try {
                if (!authChecked || !auth?.currentUser) { await authReadyPromise; authChecked = true; }
                const user = auth?.currentUser; if (!user) { console.warn("SmartLog: User missing after authReady."); return; }
                const userContext = { uid: user.uid, isAnonymous: user.isAnonymous };
                const logEntry = {
                    timestamp: serverTimestamp(), level, message: String(message), origin,
                    context: { ...JSON.parse(JSON.stringify(context || {})), sessionId, userAgent: navigator.userAgent || 'N/A', page: window.location.pathname || '/driver-app/' }, // Adjust page
                    user: userContext, category: category || null, solution: solution || null
                };
                await addDoc(collection(db, LOG_COLLECTION), logEntry);
            } catch (error) { console.error("SmartLog FATAL ERROR writing to Firestore.", error, { originalMessage: message }); if (error.code === 'permission-denied' || error.message.includes('permissions')) { console.warn("SmartLog: Disabling Firestore logging."); isDbAvailable = false; } }
         };
        const SmartLog = {
            info: (msg, origin, ctx = {}) => { writeLog('INFO', msg, origin, ctx); },
            warn: (msg, origin, ctx = {}, cat = null, sol = null) => { writeLog('WARN', msg, origin, ctx, cat, sol); },
            error: (err, origin, ctx = {}, cat = null, sol = null) => { const msg = err instanceof Error ? err.message : String(err); const stack = err instanceof Error ? err.stack : 'N/A'; writeLog('ERROR', msg, origin, { ...ctx, stack }, cat, sol); }
        };
        console.log("SmartLog part executed.");


        // --- Driver App Specific Logic ---

        // Globals
        let map;
        let driverMarker;
        let currentDriverId = localStorage.getItem('driverId'); // Retrieve saved driver ID
        let currentDriverName = localStorage.getItem('driverName'); // Retrieve saved driver name
        let watchId = null; // Geolocation watch ID
        let currentOrders = {}; // Cache current orders { orderId: orderData }
        let notificationAudio = null; // Tone.js synth
        let hasNotificationPermission = false;
        let hasGeolocationPermission = false;
        let lastLocationUpdate = 0; // Timestamp of last Firestore update

        // DOM Elements
        const DOM = {
             driverNameDisplay: document.getElementById('driver-name-display'),
             statusText: document.getElementById('status-text'),
             statusDot: document.getElementById('status-dot'),
             permissionSection: document.getElementById('permission-section'),
             requestPermsBtn: document.getElementById('request-perms-btn'),
             locationInfo: document.getElementById('location-info'),
             currentLocationText: document.getElementById('current-location-text'),
             etaText: document.getElementById('eta-text'),
             mapElement: document.getElementById('map'),
             orderList: document.getElementById('order-list'),
             loadingOrders: document.getElementById('loading-orders')
        };

        // --- Initialization ---
        async function initializeDriverApp() {
            SmartLog.info("Initializing Driver App...", "Init");
            try {
                // Check for saved driver ID
                if (!currentDriverId || !currentDriverName) {
                    // Redirect to login page if no driver ID is saved
                    SmartLog.warn("No driver ID/Name found in localStorage. Redirecting to login.", "Auth");
                    // Assuming login page is 'login.html' in the same directory
                    window.location.href = 'login.html'; // Or show login UI here
                    return;
                }
                DOM.driverNameDisplay.textContent = `: ${currentDriverName}`;

                // Wait for Firebase Auth
                updateStatus("转 转...", "yellow", true);
                await authReadyPromise;
                SmartLog.info("Firebase Auth Ready.", "Init");

                // Check and Request Permissions
                await checkAndRequestPermissions();

                // Initialize Map
                updateStatus("转 驻...", "yellow", true);
                initMap();

                // Start Geolocation only if permission granted
                if (hasGeolocationPermission) {
                    updateStatus("驻注 GPS...", "yellow", true);
                    startGeolocation();
                } else {
                     updateStatus("转 砖专 拽", "red", false);
                     SmartLog.warn("Geolocation permission not granted. GPS not started.", "Permissions");
                }

                // Initialize Notifications
                 initNotifications();

                // Attach Order Listener
                updateStatus("住专 砖转...", "yellow", true);
                listenToOrders();

                // Final status depends on permissions
                if(hasGeolocationPermission) {
                    updateStatus("GPS 驻注", "green", false); // Initial GPS status
                }

                SmartLog.info("Driver App Initialization Complete.", "Init");

            } catch (error) {
                SmartLog.error(error, "Init.Critical");
                updateStatus(`砖转 转: ${error.message}`, "red", false);
            }
        }

        // --- Status Update ---
        function updateStatus(text, color = "gray", pulse = false) {
             if (!DOM.statusText || !DOM.statusDot) return;
             SmartLog.info(`Updating Status: ${text}`, "UI.Status", { color, pulse });
             DOM.statusText.textContent = text;
             // Remove old color classes
             DOM.statusText.classList.remove('text-yellow-600', 'text-green-600', 'text-red-600', 'text-gray-600');
             DOM.statusDot.classList.remove('bg-yellow-400', 'bg-green-400', 'bg-red-400', 'bg-gray-400');
             // Add new color classes
             DOM.statusText.classList.add(`text-${color}-600`);
             DOM.statusDot.classList.add(`bg-${color}-400`);
             // Toggle pulse animation
             if (pulse) DOM.statusDot.classList.add('animate-pulse');
             else DOM.statusDot.classList.remove('animate-pulse');
        }

        // --- Permissions ---
        async function checkAndRequestPermissions() {
             SmartLog.info("Checking permissions...", "Permissions");
             let needsRequest = false;

             // Geolocation
             try {
                const geoStatus = await navigator.permissions.query({ name: 'geolocation' });
                hasGeolocationPermission = geoStatus.state === 'granted';
                if (geoStatus.state === 'prompt') needsRequest = true;
                SmartLog.info("Geolocation permission status:", "Permissions", { status: geoStatus.state });
             } catch (e) {
                SmartLog.warn("Could not query geolocation permission.", "Permissions", e);
                // Assume we need to request if query fails
                 needsRequest = true;
             }

             // Notifications
             if ('Notification' in window) {
                hasNotificationPermission = Notification.permission === 'granted';
                if (Notification.permission === 'default') needsRequest = true;
                SmartLog.info("Notification permission status:", "Permissions", { status: Notification.permission });
             } else {
                 SmartLog.warn("Notifications not supported by this browser.", "Permissions");
             }

             if (needsRequest) {
                 DOM.permissionSection.style.display = 'block';
                 DOM.requestPermsBtn.addEventListener('click', handlePermissionRequest);
                 updateStatus("转 砖专 专砖转", "yellow", true);
             } else {
                 DOM.permissionSection.style.display = 'none';
                 SmartLog.info("Permissions already granted or denied.", "Permissions");
             }
        }

        async function handlePermissionRequest() {
            SmartLog.info("Requesting permissions via button click...", "Permissions");
            let geoGranted = hasGeolocationPermission;
            let notifGranted = hasNotificationPermission;

            // Request Geolocation
            if (!hasGeolocationPermission) {
                try {
                    await new Promise((resolve, reject) => {
                         navigator.geolocation.getCurrentPosition(resolve, reject, { timeout: 10000 });
                    });
                    const geoStatus = await navigator.permissions.query({ name: 'geolocation' });
                    geoGranted = geoStatus.state === 'granted';
                    hasGeolocationPermission = geoGranted; // Update global state
                    SmartLog.info("Geolocation permission request result:", "Permissions", { status: geoStatus.state });
                    if(geoGranted && !watchId) startGeolocation(); // Start GPS if granted now
                 } catch (e) {
                    SmartLog.error(e, "Permissions", { message: "Geolocation request failed." });
                 }
            }

            // Request Notifications
            if ('Notification' in window && Notification.permission === 'default') {
                try {
                    const permission = await Notification.requestPermission();
                    notifGranted = permission === 'granted';
                    hasNotificationPermission = notifGranted; // Update global state
                    SmartLog.info("Notification permission request result:", "Permissions", { status: permission });
                     if(notifGranted) initNotifications(); // Init audio if granted now
                } catch (e) {
                     SmartLog.error(e, "Permissions", { message: "Notification request failed." });
                }
            }

            if (geoGranted && notifGranted) {
                DOM.permissionSection.style.display = 'none';
                updateStatus("专砖转 砖专", "green", false);
                // Status might be overridden by GPS soon
            } else {
                 updateStatus("拽 专砖转 住专转", "red", false);
                 DOM.requestPermsBtn.textContent = "住 拽砖 专砖转 砖"; // Update button text
                 DOM.requestPermsBtn.classList.add('btn-disabled'); // Disable for a bit?
                 setTimeout(() => DOM.requestPermsBtn.classList.remove('btn-disabled'), 5000);
            }
        }


        // --- Geolocation & Location Update ---
        function startGeolocation() {
            if (watchId) { SmartLog.info("Geolocation already watching.", "GPS"); return; } // Already running
            if (!('geolocation' in navigator)) { SmartLog.error("Geolocation not supported.", "GPS"); return; }

            SmartLog.info("Starting geolocation watchPosition...", "GPS");
            updateStatus("驻注 GPS...", "yellow", true);

            watchId = navigator.geolocation.watchPosition(
                async (position) => {
                    const { latitude, longitude, accuracy } = position.coords;
                    SmartLog.info("GPS Update Received", "GPS", { lat: latitude, lon: longitude, acc: accuracy });
                    updateStatus("GPS 驻注", "green", false);

                    // Update map marker
                    updateDriverMarkerOnMap(latitude, longitude);

                    // Update location text via reverse geocoding
                    updateLocationText(latitude, longitude);

                    // Send to Firestore (throttle updates to avoid excessive writes)
                    const now = Date.now();
                    if (now - lastLocationUpdate > 20000) { // Update every 20 seconds
                        SmartLog.info("Sending location update to Firestore...", "GPS.Firestore");
                        await updateLocationInFirestore(latitude, longitude);
                        lastLocationUpdate = now;
                    }
                },
                (error) => {
                    SmartLog.error(error, "GPS.Error");
                    let errorMsg = "砖转 GPS";
                    if (error.code === 1) errorMsg = "GPS:  专砖";
                    else if (error.code === 2) errorMsg = "GPS:  ";
                    else if (error.code === 3) errorMsg = "GPS: Timeout";
                    updateStatus(errorMsg, "red", false);
                    if(watchId) { navigator.geolocation.clearWatch(watchId); watchId = null; } // Stop watching on error
                },
                { enableHighAccuracy: true, timeout: 15000, maximumAge: 5000 } // Options
            );
        }

        async function updateLocationInFirestore(lat, lng) {
            if (!db || !currentDriverId) return;
            const locationRef = doc(db, "driverLocations", currentDriverId);
            try {
                await updateDoc(locationRef, {
                    latitude: lat,
                    longitude: lng,
                    lastUpdate: serverTimestamp()
                });
                SmartLog.info("Location updated in Firestore.", "GPS.Firestore");
            } catch (e) {
                // Handle 'not found' by creating the document
                if (e.code === 'not-found') {
                     SmartLog.warn("Driver location document not found, creating...", "GPS.Firestore");
                     try {
                          await setDoc(locationRef, { // Use setDoc to create
                               latitude: lat,
                               longitude: lng,
                               lastUpdate: serverTimestamp(),
                               driverName: currentDriverName // Optionally add name
                          });
                          SmartLog.info("Location document created in Firestore.", "GPS.Firestore");
                     } catch (createError) {
                          SmartLog.error(createError, "GPS.Firestore.Create", {message: "Failed to create location doc"});
                     }
                } else {
                     SmartLog.error(e, "GPS.Firestore.Update", {message: "Failed to update location doc"});
                }
            }
        }

        // Reverse Geocoding using Nominatim (Free, requires attribution)
        async function updateLocationText(lat, lng) {
            if (!DOM.currentLocationText) return;
            DOM.currentLocationText.textContent = ` ${lat.toFixed(4)}, ${lng.toFixed(4)}`; // Fallback text
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=16`); // Zoom 16 for street level
                if (!response.ok) throw new Error(`Nominatim error: ${response.status}`);
                const data = await response.json();
                if (data && data.display_name) {
                    // Extract relevant parts (e.g., road, suburb, city)
                    const addressParts = data.display_name.split(', ');
                    const shortAddress = addressParts.slice(0, 3).join(', '); // Take first 3 parts
                    DOM.currentLocationText.textContent = ` ${shortAddress}`;
                    SmartLog.info("Reverse geocoding success", "GPS.ReverseGeocode", { address: shortAddress });
                } else {
                     SmartLog.warn("Reverse geocoding failed: No display_name", "GPS.ReverseGeocode", { data });
                }
            } catch (error) {
                SmartLog.error(error, "GPS.ReverseGeocode");
                // Keep the coordinates as text on error
            }
             // Add Nominatim attribution somewhere visible if using their data extensively
             // e.g., in a footer or settings page: "Location data 漏 OpenStreetMap contributors"
        }

        // --- Map Handling ---
        function initMap() {
             try {
                 map = L.map(DOM.mapElement).setView([32.0853, 34.7818], 13); // Tel Aviv center
                 L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                     attribution: '&copy; OSM', // Keep attribution short
                     maxZoom: 18, // Limit zoom slightly for mobile performance
                 }).addTo(map);
                 SmartLog.info("Map initialized", "Map");
             } catch (e) {
                  SmartLog.error(e, "Map.Init");
                  if (DOM.mapElement) DOM.mapElement.innerHTML = '<p class="text-red-500 p-4 text-center">砖 注转 驻</p>';
             }
        }

        function updateDriverMarkerOnMap(lat, lng) {
             if (!map) return;
             const latLng = [lat, lng];
             if (driverMarker) {
                 driverMarker.setLatLng(latLng);
             } else {
                 // Use a simple circle marker for performance
                 driverMarker = L.circleMarker(latLng, {
                     radius: 8,
                     fillColor: "#3a86ff", // Blue
                     color: "#fff",
                     weight: 2,
                     opacity: 1,
                     fillOpacity: 0.8
                 }).addTo(map);
                 SmartLog.info("Driver marker added to map", "Map");
             }
             map.panTo(latLng); // Gently pan map to keep marker visible
        }

         // --- Order Handling ---
        function listenToOrders() {
             SmartLog.info("Listening to orders for driver:", "Orders", { driverId: currentDriverId });
             const q = query(
                 collection(db, "orders"),
                 where("driver.id", "==", currentDriverId),
                 where("status", "in", ["砖", "转 拽", "专"]) // Relevant statuses
                 // orderBy("createdAt", "desc") // Maybe order by ETA or sequence later
             );

             onSnapshot(q, (snapshot) => {
                 SmartLog.info(`Orders snapshot received: ${snapshot.docChanges().length} changes`, "Orders");
                 DOM.loadingOrders.style.display = 'none'; // Hide loader once first snapshot arrives
                 let newOrderDetected = false;

                 snapshot.docChanges().forEach((change) => {
                     const orderId = change.doc.id;
                     const orderData = { id: orderId, ...change.doc.data() };

                     if (change.type === "added") {
                         SmartLog.info("New order added:", "Orders", { orderId });
                         currentOrders[orderId] = orderData;
                         // Check if it's a "newly assigned" order to trigger notification
                         if (orderData.status === '砖') {
                              newOrderDetected = true; // Mark for notification AFTER processing all changes
                         }
                     } else if (change.type === "modified") {
                         SmartLog.info("Order modified:", "Orders", { orderId, status: orderData.status });
                         currentOrders[orderId] = orderData;
                     } else if (change.type === "removed") {
                         SmartLog.info("Order removed:", "Orders", { orderId });
                         delete currentOrders[orderId];
                     }
                 });

                 renderOrderList(); // Update the UI

                 // Trigger notification/sound only once after processing all changes
                 if (newOrderDetected) {
                     handleNewOrderNotification();
                 }

             }, (error) => {
                 SmartLog.error(error, "Orders.Listener");
                 updateStatus("砖 住专 砖转", "red", false);
                 DOM.loadingOrders.innerHTML = '<p class="text-red-500">砖 注转 砖转</p>';
             });
        }

        function renderOrderList() {
             const ordersArray = Object.values(currentOrders)
                                     .sort((a, b) => (a.status === '砖' ? -1 : 1)); // Show '砖' first
             if (!DOM.orderList) return;

             if (ordersArray.length === 0) {
                 DOM.orderList.innerHTML = `<p class="text-center text-gray-500 py-10"> 砖转 驻注转 专注.</p>`;
                 return;
             }

             DOM.orderList.innerHTML = ordersArray.map(order => createOrderCard(order)).join('');
             feather.replace(); // Re-apply icons
        }

        function createOrderCard(order) {
            let cardClass = "bg-white p-4 rounded-lg shadow";
            let actionButton = '';
            let statusText = order.status || ' 注';
            let statusColor = "text-gray-500";

            switch (order.status) {
                case '砖':
                    cardClass += " notification-card"; // Add pulse animation
                    statusText = "砖 砖 - 转 砖专";
                    statusColor = "text-yellow-600 font-bold";
                    actionButton = `
                        <button class="w-full py-2 px-4 rounded bg-green-500 text-white font-semibold hover:bg-green-600 transition duration-150 btn-success"
                                onclick="window.acknowledgeOrder('${order.id}')">
                            <i data-feather="check-circle" class="inline-block w-4 h-4 ml-1"></i>
                            拽转 转 注住
                        </button>`;
                    break;
                case '转 拽':
                    statusText = "注住 住";
                    statusColor = "text-blue-600";
                    // No action button needed here for the driver
                     actionButton = `<p class="text-center text-sm text-gray-500 italic">转 住 注住...</p>`;
                    break;
                 case '专':
                    statusText = "专 拽";
                    statusColor = "text-green-600 font-semibold";
                    actionButton = `
                        <button class="w-full py-2 px-4 rounded bg-green-600 text-white font-semibold hover:bg-green-700 transition duration-150 btn-success"
                                onclick="window.completeOrder('${order.id}')">
                            <i data-feather="flag" class="inline-block w-4 h-4 ml-1"></i>
                             住 砖转 砖
                        </button>`;
                    break;
                 default:
                     cardClass += " opacity-70"; // Dim other statuses slightly
            }

            // Button row
            const buttons = `
                 <div class="grid grid-cols-2 gap-2 mt-3 text-sm">
                    <a href="tel:${order.customer?.phone || ''}" class="py-2 px-3 rounded bg-gray-200 text-gray-700 font-medium hover:bg-gray-300 transition duration-150 text-center">
                       <i data-feather="phone" class="inline-block w-4 h-4 ml-1"></i> 转拽砖专 拽
                    </a>
                     <a href="https://www.google.com/maps/dir/?api=1&destination=${encodeURIComponent(order.address || '')}" target="_blank" class="py-2 px-3 rounded bg-blue-500 text-white font-medium hover:bg-blue-600 transition duration-150 text-center">
                       <i data-feather="navigation" class="inline-block w-4 h-4 ml-1"></i> 砖 住 (Maps)
                    </a>
                 </div>`;


             return `
                <div class="${cardClass}" id="order-${order.id}">
                    <div class="flex justify-between items-start mb-2">
                        <div>
                            <h3 class="text-lg font-bold text-gray-900">${order.customer?.name || '拽  注'}</h3>
                            <p class="text-sm text-gray-600">${order.address || '转转  爪'}</p>
                        </div>
                        <span class="text-xs font-medium ${statusColor} whitespace-nowrap">${statusText}</span>
                    </div>
                     <p class="text-xs text-gray-500 mb-3">注专转: ${order.notes || ''}</p>

                    ${actionButton}
                    ${buttons}
                </div>
             `;
        }

        // --- Order Actions ---
        window.acknowledgeOrder = async (orderId) => {
            SmartLog.info("Acknowledging order...", "Orders.Action", { orderId });
            try {
                const orderRef = doc(db, "orders", orderId);
                await updateDoc(orderRef, { status: "转 拽" });
                SmartLog.info("Order status updated to '转 拽'", "Orders.Action", { orderId });
                // Optional: Stop notification sound if playing
                stopNotificationSound();
                // Remove pulse animation
                document.getElementById(`order-${orderId}`)?.classList.remove('notification-card');
            } catch (e) {
                SmartLog.error(e, "Orders.Action.Acknowledge");
                alert("砖 砖专 .");
            }
        };

        window.completeOrder = async (orderId) => {
             SmartLog.info("Completing order...", "Orders.Action", { orderId });
             if (!confirm(" 转  砖专爪 住 砖  砖?")) return;
             try {
                // In a real app, you might want more complex logic here
                // e.g., signature capture, photo proof, etc. before setting to 砖
                const orderRef = doc(db, "orders", orderId);
                await updateDoc(orderRef, { status: "砖", completedAt: serverTimestamp() });
                SmartLog.info("Order status updated to '砖'", "Orders.Action", { orderId });
                // Order will disappear from the list on next snapshot update
             } catch (e) {
                 SmartLog.error(e, "Orders.Action.Complete");
                 alert("砖 住 .");
             }
        };


        // --- Notifications ---
        function initNotifications() {
             if (!hasNotificationPermission || !window.Tone) return;
             try {
                // Create a simple synth sound
                notificationAudio = new Tone.Synth({
                     oscillator: { type: "sine" }, // Simple sine wave
                     envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 }
                }).toDestination();
                SmartLog.info("Notification audio initialized.", "Notifications");
             } catch (e) {
                SmartLog.error(e, "Notifications.InitAudio", { message: "Failed to initialize Tone.js synth." });
             }
        }

        function handleNewOrderNotification() {
             SmartLog.info("New order detected, handling notification...", "Notifications");

             // Play sound (if permission granted and synth initialized)
             if (notificationAudio && Tone?.context?.state === 'running') {
                try {
                    notificationAudio.triggerAttackRelease("C5", "8n", Tone.now()); // Play a C5 note
                    notificationAudio.triggerAttackRelease("G5", "8n", Tone.now() + 0.2); // Play a G5 note slightly after
                    SmartLog.info("Notification sound played.", "Notifications");
                } catch(e) {
                     SmartLog.error(e, "Notifications.PlaySound");
                }
             } else if (notificationAudio && Tone?.context?.state !== 'running') {
                 // Try to resume audio context if suspended (common in browsers)
                 Tone.start().then(() => {
                      SmartLog.info("Audio context resumed by Tone.start(). Retrying sound.", "Notifications");
                      try {
                           notificationAudio.triggerAttackRelease("C5", "8n", Tone.now());
                           notificationAudio.triggerAttackRelease("G5", "8n", Tone.now() + 0.2);
                      } catch(e) { SmartLog.error(e, "Notifications.PlaySoundRetry"); }
                 }).catch(e => SmartLog.error(e, "Notifications.ToneStartFailed"));
             } else {
                 SmartLog.warn("Could not play notification sound (permission or init issue).", "Notifications");
             }


             // Show browser notification (if permission granted)
             if (hasNotificationPermission && 'Notification' in window) {
                 const notification = new Notification(" 砖 转拽!", {
                     body: "砖  砖 砖 砖转 砖专.",
                     icon: "https://i.postimg.cc/ryPT3r29/image.png", // Use your app icon
                     vibrate: [200, 100, 200] // Vibration pattern
                 });
                 notification.onclick = () => {
                     window.focus(); // Bring app to foreground on click
                     SmartLog.info("Notification clicked.", "Notifications");
                 };
                 SmartLog.info("Browser notification shown.", "Notifications");
             } else {
                  SmartLog.warn("Could not show browser notification (permission denied or unsupported).", "Notifications");
             }
        }

        function stopNotificationSound() {
             // Placeholder if needed - Tone.js sounds usually stop automatically
             SmartLog.info("Stopping notification sound (if playing).", "Notifications");
             // If using a looping sound, you'd call stop() here.
             // For simple triggerAttackRelease, it stops on its own.
        }

        // --- Service Worker Registration ---
        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('./sw.js')
                        .then(registration => {
                            SmartLog.info('ServiceWorker registration successful', 'PWA', { scope: registration.scope });
                        })
                        .catch(err => {
                            SmartLog.error(err, 'PWA', { message: 'ServiceWorker registration failed' });
                        });
                });
            } else {
                 SmartLog.warn("Service Worker not supported.", "PWA");
            }
        }


        // --- Start Application ---
        document.addEventListener('DOMContentLoaded', () => {
            SmartLog.info("DOMContentLoaded fired.", "Init");
            registerServiceWorker(); // Register SW early
            initializeDriverApp(); // Start main app logic
             // Make feather icons work
             try { feather.replace(); } catch (e) { SmartLog.warn("Feather icons replace failed.", "UI", e); }
        });

    </script>

</body>
</html>
